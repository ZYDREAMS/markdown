#     <center>**基于Redis实现分布式锁** </center>

## 一、为什么用Redis可以实现分布式锁
Redis作为分布式锁有其天然的优势，首先我们都知道Redis是单线程的,单线程意味着什么？就是所有对Redis的请求Redis都只用一个线程去处理，这便能够有效的实现共享资源对所有分布式环境下的进程间的同步。
Redis也很好的提供了原子性的操作去获取或释放锁。在旧版本的redis中（指2.6.12版本之前），使用redis实现分布式锁一般需要setNX、expire、getSet、del等命令。 Redis 从2.6.12版本开始 set 命令支持 NX 、 PX 这些参数来达到 setnx 、 setex 、 psetex 命令的效果。由于SET命令加上选项已经可以完全取代SETNX, SETEX, PSETEX的功能，而且会发现旧版本的分布式锁的实现有很多逻辑判断的原子操作以及本地时间等并没有控制好。所以在将来的版本中，redis可能会不推荐使用并且最终抛弃旧版本那几个命令。

## 二、Redis分布式锁命令介绍
2.6.12版本开始 set 命令支持 NX 、 PX 这些参数，提供了如下一个原子性的事务锁：
```properties
SET key value NX PX 过期时间
```
这个命令可以分成两部分理解：
1. set key value nx,即即该key不存在的话才能对其进行设置
2. expire key seconds,即设置该key的过期时间

但是要注意的是不能将上述的两个流程分开去执行，不然会造成一些问题，比如:

>1.如果一个set key的命令设置了key，然后程序异常了，expire时间没有设置，那么这个key会一直锁住，其他分布式环境下的请求也无法完成。

>2.第一个线程如果一个set key时出现了异常，但是直接执行了expire，过了一会儿之后第二个线程进行set key，还没怎么执行代码，结果key过期了，第二个还在执行，来的第三个的线程也会同时进入了锁。

## 三、Redis实现分布式锁要考虑的几个问题
1. 死锁问题
(1)为了防止死锁，redis至少需要设置一个超时时间；
(2)当锁自动释放了，但是程序并没有执行完毕，这时候其他线程又获取到锁执行同样的程序，可能会造成并发问题.
如果可以通过在key快要过期的时候判断下任务有没有执行完毕，如果还没有那就自动延长过期时间，那么确实可以解决并发的问题，但是超时时长也就失去了意义。所以一种最好的解决方式可能是在锁超时的时候通知服务器去停掉超时任务，但是结合上Redis的消息通知机制不免有些过重了。
所以这个问题上，分布式锁的Redis实现并不靠谱。在Redisson中也没有找到解决方式。或者使用Zookepper将超时消息发送给客户端去执行超时情况下的业务逻辑。
2. 锁释放问题
(1)每个获取redis锁的线程应该释放自己获取到的锁，而不是其他线程的，所以我们需要在每个线程获取锁的时候给锁做上不同的标记以示区分；
(2)由1带来的问题是线程在释放锁的时候需要判断当前锁是否属于自己，如果属于自己才释放，这里涉及到逻辑判断语句，至少是两个操作在进行，那么我们需要考虑这两个操作要在一个原子内执行，否者在两个行为之间可能会有其他线程插入执行，导致程序紊乱。
(3)Redis开发文档，并没有发现释放锁相关的原子操作。不过幸运的是，在Redis中执行原子操作不止有通过官方提供的命令的方式，还有另外一种方式，就是Lua脚本。
3. 单点问题
(1)单实例的redis（这里指只有一个master节点）往往是不可靠的，虽然实现起来相对简单一些，但是会面临着宕机等不可用的场景，即使在主从复制的时候也显得并不可靠（因为redis的主从复制往往是异步的）。

以上问题可参考：
关于Martin Kleppmann的Redlock的分析：中文地址 http://redis.cn/topics/distlock.html
redis之父antirez对Redlock的评价，文中主要提到了网络延迟和本地时钟的修改（不管是时间服务器或人为修改）对这种算法可能造成的影响。：原文地址：http://antirez.com/news/101
